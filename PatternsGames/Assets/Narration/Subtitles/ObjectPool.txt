1
00:00:00,000 --> 00:00:06,240
Game Overview. This game is an endless runner inspired by the classic offline dinosaur game.

2
00:00:07,040 --> 00:00:12,640
The player runs automatically through an infinite level and must jump or crouch to avoid incoming

3
00:00:12,640 --> 00:00:18,080
obstacles. The goal is to survive as long as possible and beat the highest score.

4
00:00:19,040 --> 00:00:25,520
Use of object pool. Obstacles appear continuously and move toward the player at increasing speed.

5
00:00:26,320 --> 00:00:31,760
Because the game never ends, obstacles must be spawned and removed constantly during gameplay.

6
00:00:32,640 --> 00:00:38,000
Creating and destroying game objects every second would be inefficient and could lead to performance

7
00:00:38,000 --> 00:00:43,280
issues. To solve this problem, the game uses the object pool design pattern.

8
00:00:44,160 --> 00:00:49,520
Object pooling is an optimization technique that reduces the cost of repeatedly creating and

9
00:00:49,520 --> 00:00:56,000
destroying objects. Instead of instantiating obstacles at runtime, a fixed number of obstacles

10
00:00:56,000 --> 00:01:02,640
are created in advance and stored in a disabled pool. The pool contains multiple obstacle types.

11
00:01:03,280 --> 00:01:08,960
In this implementation, there are four different obstacle variants, with two instances of each

12
00:01:08,960 --> 00:01:15,280
type stored in the pool. All pooled objects are created once at the start of the game and remain

13
00:01:15,280 --> 00:01:21,200
inactive until needed. When the game needs to spawn an obstacle, it requests an object from the

14
00:01:21,200 --> 00:01:27,840
pool using a unique tag. The pool returns an inactive object, activates it, and places it into

15
00:01:27,840 --> 00:01:34,560
the game world. If a pool is temporarily empty, a new object can be created and added dynamically,

16
00:01:34,560 --> 00:01:41,680
ensuring the game never blocks or crashes. When an obstacle moves off screen or is no longer needed,

17
00:01:41,760 --> 00:01:48,240
it is not destroyed. Instead, the object is deactivated and returned back to the pool,

18
00:01:48,240 --> 00:01:54,320
where it waits to be reused. This cycle allows the same objects to be reused over and over again.

19
00:01:55,840 --> 00:02:02,240
Visualization on screen. Each pooled object is assigned a unique identifier and labeled in the scene.

20
00:02:03,120 --> 00:02:08,400
This makes it easy to visualize which objects are currently active, which ones are inactive in

21
00:02:08,400 --> 00:02:12,320
the pool and how the pool is being reused during gameplay.

